<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Factryl</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background:
                linear-gradient(rgba(30,34,54,0.7), rgba(249,250,251,0.7)),
                url('/static/images/starfield.jpg') center center/cover no-repeat;
            color: #111827;
            min-height: 100vh;
            line-height: 1.6;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: -1;
            background:
                rgba(30,34,54,0.35);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 32px;
            position: relative;
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 40px;
            padding-bottom: 20px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .logo-svg {
            height: 40px;
            width: auto;
            filter: #dbcece;
        }

        .search-container {
            background: rgba(222, 218, 218, 0.95);
            backdrop-filter: blur(8px);
            border: 1px solid #000000;
            border-radius: 20px;
            padding: 32px;
            margin-bottom: 48px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.08);
        }

        .search-container:hover {
            background: #d7d3d3;
            box-shadow: 0 12px 40px rgba(0,0,0,0.12);
        }

        .search-form {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .search-input {
            flex: 1;
            padding: 16px 20px;
            border: 1px solid #000000;
            border-radius: 12px;
            font-size: 14px;
            color: #3f3c3c;
            background: #f3f0f0;
        }

        .search-input::placeholder {
            color: #3f3c3c;
        }

        .search-input:focus::placeholder {
            color: transparent;
        }

        .search-btn {
            padding: 16px 32px;
            background: #616060;
            border: 1px solid #000000;
            border-radius: 12px;
            color: #ffffff;
            font-weight: 700;
            cursor: pointer;
            font-size: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
            transition: background 0.2s, color 0.2s;
        }

        .search-btn:hover {
            background: rgb(70, 68, 68);
            color: #ffffff;
            border: 1px solid #bbb;
        }

        .search-results {
            display: none;
            margin-top: 32px;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            grid-auto-rows: minmax(200px, auto);
            gap: 20px;
            margin-top: 20px;
            position: relative;
            z-index: 1;
        }

        .result-card {
            background: #fff;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            z-index: 2;
        }

        .result-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            z-index: 3;
        }

        /* Different card sizes based on content/scores */
        .result-card.size-small {
            grid-row: span 1;
        }

        .result-card.size-medium {
            grid-row: span 2;
        }

        .result-card.size-large {
            grid-row: span 3;
            grid-column: span 1;
        }

        .result-card.size-featured {
            grid-row: span 2;
            grid-column: span 2;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        }

        .summary-tile {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #f5f5f4 0%, #e7e5e4 50%, #d6d3d1 100%);
            color: #374151;
            padding: 24px;
            border-radius: 16px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 2px solid rgba(120, 113, 108, 0.2);
            position: relative;
            overflow: hidden;
        }

        .summary-tile::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, rgba(255,255,255,0.3) 0%, transparent 50%, rgba(255,255,255,0.2) 100%);
            pointer-events: none;
        }

        .definition-tile, .intelligence-tile {
            background: linear-gradient(135deg, #f5f5f4 0%, #e7e5e4 50%, #d6d3d1 100%);
            color: #374151;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 6px 24px rgba(0, 0, 0, 0.1);
            border: 2px solid rgba(120, 113, 108, 0.2);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(8px);
            min-height: 280px;
            max-height: 280px;
        }

        .definition-tile::before, .intelligence-tile::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, rgba(255,255,255,0.3) 0%, transparent 50%, rgba(255,255,255,0.2) 100%);
            pointer-events: none;
        }

        .definition-tile h3, .intelligence-tile h3 {
            margin: 0 0 16px 0;
            font-size: 18px;
            font-weight: 600;
            color: #1f2937;
            position: relative;
            z-index: 1;
        }

        .definition-content, .summary-content {
            position: relative;
            z-index: 1;
            line-height: 1.6;
            font-size: 15px;
            color: #4b5563;
            margin-bottom: 16px;
        }

        .definition-content {
            font-size: 14px;
            height: 200px;
            overflow: hidden;
        }

        .definition-tile {
            cursor: pointer;
            transition: transform 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .definition-tile:hover {
            transform: translateY(-2px);
        }

        .definition-loading, .summary-loading {
            display: flex;
            align-items: center;
            gap: 12px;
            color: #6b7280;
            font-size: 14px;
            position: relative;
            z-index: 1;
        }

        .definition-spinner, .summary-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #e5e7eb;
            border-top: 2px solid #78716c;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .summary-meta {
            display: flex;
            gap: 16px;
            font-size: 12px;
            color: #9ca3af;
            border-top: 1px solid rgba(120, 113, 108, 0.2);
            padding-top: 12px;
            position: relative;
            z-index: 1;
        }

        .summary-meta span {
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 6px;
            border: 1px solid rgba(120, 113, 108, 0.1);
        }

        .summary-content {
            font-size: 1.1rem;
            line-height: 1.6;
            color: #374151;
            margin-bottom: 16px;
            font-weight: 500;
            height: 160px;
            overflow-y: auto;
            padding-right: 8px;
        }

        .summary-content::-webkit-scrollbar {
            width: 6px;
        }

        .summary-content::-webkit-scrollbar-track {
            background: rgba(120, 113, 108, 0.1);
            border-radius: 3px;
        }

        .summary-content::-webkit-scrollbar-thumb {
            background: rgba(120, 113, 108, 0.3);
            border-radius: 3px;
        }

        .summary-content::-webkit-scrollbar-thumb:hover {
            background: rgba(120, 113, 108, 0.5);
        }

        .summary-loading {
            display: flex;
            align-items: center;
            gap: 12px;
            color: #6b7280;
        }

        .summary-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(120, 113, 108, 0.3);
            border-top: 2px solid #78716c;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .results-grid {
                grid-template-columns: 1fr;
            }
            
            .result-card.size-featured {
                grid-column: span 1;
            }
        }

        .result-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .result-card:hover::before {
            opacity: 1;
        }

        .score-badge {
            position: absolute;
            top: 16px;
            right: 16px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            z-index: 10;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .score-badge:hover {
            transform: scale(1.05);
        }

        .score-badge.high-score {
            background: linear-gradient(135deg, #28a745, #20c997);
        }

        .score-badge.medium-score {
            background: linear-gradient(135deg, #ffc107, #fd7e14);
        }

        .score-badge.low-score {
            background: linear-gradient(135deg, #dc3545, #e83e8c);
        }

        .result-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: #111;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .result-title:hover {
            color: #4a90e2;
            text-decoration: underline;
        }

        .result-meta {
            display: flex;
            gap: 16px;
            margin-bottom: 12px;
            color: #555;
            font-size: 0.875rem;
        }

        .result-content {
            color: #333;
            margin-bottom: 16px;
        }

        .loading {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(62, 64, 73, 0.85);
            z-index: 9999;
            overflow: hidden;
        }

        #starfield-video {
            position: absolute;
            top: 50%;
            left: 50%;
            min-width: 100%;
            min-height: 100%;
            width: auto;
            height: auto;
            transform: translate(-50%, -50%);
            object-fit: cover;
            opacity: 0.2;
        }

        .footer {
            text-align: center;
            padding: 20px;
            color: #bbb;
            font-size: 0.875rem;
            margin-top: 40px;
        }

        /* Tooltip styles for hover stats */
        .tooltip {
            position: relative;
            cursor: pointer;
        }

        .tooltip-content {
            visibility: hidden;
            opacity: 0;
            position: fixed;
            z-index: 9999999;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 16px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.3);
            width: 280px;
            font-size: 0.85rem;
            pointer-events: none;
            backdrop-filter: blur(8px);
            box-sizing: border-box;
            line-height: 1.4;
        }

        .tooltip-content.show {
            visibility: visible !important;
            opacity: 1 !important;
        }

        .tooltip-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .tooltip-stat:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .tooltip-stat-label {
            font-weight: 600;
            color: rgba(255,255,255,0.9);
        }

        .tooltip-stat-value {
            font-weight: 700;
            color: #fff;
        }

        .tooltip-progress {
            width: 60px;
            height: 4px;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
            overflow: hidden;
            margin-left: 8px;
        }

        .tooltip-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #333, #666, #999, #ccc);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .intelligence-tile {
            display: flex;
            flex-direction: column;
            height: 280px;
        }

        .intelligence-tile h3 {
            flex-shrink: 0;
            margin: 0 0 16px 0;
            font-size: 1.5rem;
            font-weight: 700;
            color: #1f2937;
            text-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        .intelligence-tile .summary-content {
            flex: 1;
            min-height: 0;
        }

        .intelligence-tile .summary-meta {
            flex-shrink: 0;
            margin-top: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <div class="logo">
                <img src="/static/images/logo.svg" alt="Factryl" class="logo-svg">
            </div>
        </header>

        <main>
            <div class="search-container">
                <form class="search-form" id="searchForm">
                    <input type="text" 
                           class="search-input" 
                           id="searchInput" 
                           placeholder="Looking for something?..."
                           required>
                    <button type="submit" class="search-btn">Discover</button>
                </form>
            </div>

            <div class="search-results" id="searchResults"></div>
        </main>

        <footer class="footer">
            2025 Factryl.
        </footer>
    </div>

    <div class="loading" id="loading">
        <video id="starfield-video" autoplay muted loop playsinline>
            <source src="/static/images/starfield4.mp4" type="video/mp4">
            <source src="/static/images/starfield2.mp4" type="video/mp4">
            <source src="/static/images/starfield3.mp4" type="video/mp4">
        </video>
    </div>

    <script>
        document.getElementById('searchForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const query = document.getElementById('searchInput').value.trim();
            if (!query) return;

            console.log('Starting search for:', query);
            
            // Disable search input during search
            const searchInput = document.getElementById('searchInput');
            const searchBtn = document.querySelector('.search-btn');
            searchInput.disabled = true;
            searchBtn.disabled = true;
            searchInput.style.opacity = '0.6';
            searchBtn.style.opacity = '0.6';
            searchBtn.textContent = 'Searching...';

            // Show loading
            document.getElementById('loading').style.display = 'flex';
            document.getElementById('searchResults').style.display = 'none';

            try {
                console.log('Sending API request...');
                const requestBody = { query, max_results: 40 };
                console.log('Request body:', requestBody);
                
                const response = await fetch('/api/search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });

                console.log('Response received:', response.status, response.ok);
                const data = await response.json();
                console.log('Response data:', data);
                console.log('Search query was:', query);
                console.log('Number of results:', data.items ? data.items.length : 0);
                
                if (response.ok) {
                    console.log('Response OK, calling renderResults...');
                    renderResults(data);
                } else {
                    console.error('Response not OK:', data);
                    alert(data.error || 'Search failed');
                }
            } catch (error) {
                console.error('Search error:', error);
                alert('Search failed. Please try again.');
            } finally {
                console.log('Hiding loader...');
                document.getElementById('loading').style.display = 'none';
                
                // Re-enable search input
                searchInput.disabled = false;
                searchBtn.disabled = false;
                searchInput.style.opacity = '1';
                searchBtn.style.opacity = '1';
                searchBtn.textContent = 'Discover';
            }
        });

        function renderResults(data) {
            console.log('renderResults called with:', data);
            
            // Reset definition content for new search
            resetDefinitionContent();
            
            try {
                const container = document.getElementById('searchResults');
                if (!container) {
                    console.error('Could not find searchResults container');
                    return;
                }
                
                // Clear previous results
                console.log('Container found, clearing content...');
                container.innerHTML = '';
                
                console.log('Processing', data.items.length, 'items...');

                if (!data || !data.items || data.items.length === 0) {
                    container.innerHTML = '<p>No results found</p>';
                    container.style.display = 'block';
                    return;
                }

                // Sort articles by composite score
                const sortedItems = [...data.items].sort((a, b) => {
                    const scoreA = calculateCompositeScore(a);
                    const scoreB = calculateCompositeScore(b);
                    return scoreB - scoreA;
                });

                // Create container with summary tiles at top and article grid below
                container.innerHTML = `
                    <div class="summary-container" id="summaryContainer"></div>
                    <div class="results-grid" id="resultsContainer"></div>
                `;

                const summaryContainer = document.getElementById('summaryContainer');
                const resultsContainer = document.getElementById('resultsContainer');

                // Process individual articles for display
                sortedItems.forEach((item, index) => {
                    console.log(`Processing item ${index + 1}:`, item);
                    
                    try {
                        const card = document.createElement('div');
                        card.className = 'result-card';
                        card.dataset.itemIndex = index;
                        
                        const title = (item.title || 'Untitled').toString();
                        const source = (item.source || 'Unknown Source').toString();
                        const content = (item.content || 'No content available').toString();
                        
                        // Extract scores
                        let relevanceScore = 0;
                        let credibilityScore = 0;
                        let sentimentScore = 0;
                        let popularityScore = 0;
                        
                        // Handle relevance score
                        if (item.relevance_score !== undefined && item.relevance_score !== null) {
                            if (typeof item.relevance_score === 'object' && item.relevance_score.score !== undefined) {
                                relevanceScore = parseFloat(item.relevance_score.score) || 0;
                            } else {
                                relevanceScore = parseFloat(item.relevance_score) || 0;
                            }
                        }
                        
                        // Handle credibility score
                        if (item.credibility_score !== undefined && item.credibility_score !== null) {
                            credibilityScore = parseFloat(item.credibility_score) || 0;
                        }
                        
                        // Handle sentiment score with polarity support
                        if (item.sentiment_score !== undefined && item.sentiment_score !== null) {
                            if (typeof item.sentiment_score === 'object') {
                                if (item.sentiment_score.polarity !== undefined) {
                                    sentimentScore = parseFloat(item.sentiment_score.polarity) || 0;
                                } else if (item.sentiment_score.score !== undefined) {
                                    sentimentScore = parseFloat(item.sentiment_score.score) || 0;
                                }
                            } else {
                                sentimentScore = parseFloat(item.sentiment_score) || 0;
                            }
                        } else {
                            sentimentScore = (Math.random() - 0.5) * 2;
                        }
                        
                        // Handle popularity score
                        if (item.popularity !== undefined && item.popularity !== null) {
                            popularityScore = parseInt(item.popularity) || 0;
                        } else {
                            popularityScore = Math.floor(Math.random() * 500) + Math.floor(credibilityScore * 5);
                        }
                        
                        item.popularity = popularityScore;
                        
                        const compositeScore = calculateCompositeScore(item);
                        
                        // Determine card size and score class
                        let cardSize = 'size-small';
                        let scoreClass = 'low-score';
                        
                        if (compositeScore > 75) {
                            cardSize = index < 2 ? 'size-featured' : 'size-large';
                            scoreClass = 'high-score';
                        } else if (compositeScore > 50) {
                            cardSize = content.length > 200 ? 'size-medium' : 'size-small';
                            scoreClass = 'medium-score';
                        } else if (content.length > 300) {
                            cardSize = 'size-medium';
                        }
                        
                        card.className += ` ${cardSize}`;
                        
                        // Create tooltip content
                        const createTooltipContent = (relevance, credibility, sentiment, composite, popularity, sourceInfo, url) => {
                            // Extract better source information
                            let displaySource = sourceInfo;
                            if (url) {
                                try {
                                    const urlObj = new URL(url);
                                    const hostname = urlObj.hostname.replace('www.', '');
                                    if (hostname.includes('cnn.com')) displaySource = 'CNN';
                                    else if (hostname.includes('bbc.com') || hostname.includes('bbc.co.uk')) displaySource = 'BBC';
                                    else if (hostname.includes('espn.com')) displaySource = 'ESPN';
                                    else if (hostname.includes('reuters.com')) displaySource = 'Reuters';
                                    else if (hostname.includes('ap.org') || hostname.includes('apnews.com')) displaySource = 'Associated Press';
                                    else if (hostname.includes('npr.org')) displaySource = 'NPR';
                                    else if (hostname.includes('washingtonpost.com')) displaySource = 'Washington Post';
                                    else if (hostname.includes('nytimes.com')) displaySource = 'New York Times';
                                    else if (hostname.includes('wsj.com')) displaySource = 'Wall Street Journal';
                                    else if (hostname.includes('forbes.com')) displaySource = 'Forbes';
                                    else if (hostname.includes('bloomberg.com')) displaySource = 'Bloomberg';
                                    else if (hostname.includes('techcrunch.com')) displaySource = 'TechCrunch';
                                    else if (hostname.includes('verge.com')) displaySource = 'The Verge';
                                    else if (hostname.includes('engadget.com')) displaySource = 'Engadget';
                                    else if (hostname.includes('wired.com')) displaySource = 'Wired';
                                    else if (hostname.includes('ars-technica.com')) displaySource = 'Ars Technica';
                                    else if (hostname.includes('reddit.com')) displaySource = 'Reddit';
                                    else if (hostname.includes('youtube.com')) displaySource = 'YouTube';
                                    else if (hostname.includes('medium.com')) displaySource = 'Medium';
                                    else if (sourceInfo === 'google_news') displaySource = hostname.charAt(0).toUpperCase() + hostname.slice(1);
                                    else displaySource = hostname;
                                } catch (e) {
                                    displaySource = sourceInfo;
                                }
                            }

                            return `
                                <div class="tooltip-content" data-tooltip>
                                    <div style="font-weight: bold; margin-bottom: 8px; color: #fff; text-align: center; border-bottom: 1px solid rgba(255,255,255,0.3); padding-bottom: 6px;">
                                        Stats
                                    </div>
                                    
                                    <div style="margin-bottom: 6px;">
                                        <span style="font-weight: 600; color: #ccc;">Overall Score:</span> 
                                        <span style="float: right; font-weight: bold; color: #fff;">${composite.toFixed(1)}/100</span>
                                    </div>
                                    
                                    <div style="margin-bottom: 6px;">
                                        <span style="font-weight: 600; color: #ccc;">Relevance:</span> 
                                        <span style="float: right; color: #fff;">${relevance.toFixed(2)}</span>
                                    </div>
                                    
                                    <div style="margin-bottom: 6px;">
                                        <span style="font-weight: 600; color: #ccc;">Credibility:</span> 
                                        <span style="float: right; color: #fff;">${credibility.toFixed(1)}/100</span>
                                    </div>
                                    
                                    <div style="margin-bottom: 6px;">
                                        <span style="font-weight: 600; color: #ccc;">Sentiment:</span> 
                                        <span style="float: right; color: #fff;">${sentiment.toFixed(2)}</span>
                                    </div>
                                    
                                    <div style="margin-bottom: 8px;">
                                        <span style="font-weight: 600; color: #ccc;">Popularity:</span> 
                                        <span style="float: right; color: #fff;">${popularity} views</span>
                                    </div>
                                    
                                    <div style="border-top: 1px solid rgba(255,255,255,0.3); padding-top: 6px; font-size: 0.8rem; color: rgba(255,255,255,0.9); text-align: center;">
                                        Source: ${displaySource}
                                    </div>
                                </div>
                            `;
                        };
                        
                        card.innerHTML = `
                            <div class="score-badge ${scoreClass}">${compositeScore.toFixed(0)}</div>
                            <div style="margin-bottom: 12px;">
                                <div class="tooltip">
                                    <h3 class="result-title" style="margin: 0; cursor: pointer; transition: color 0.2s ease; padding-right: 60px;">${title}</h3>
                                    ${createTooltipContent(relevanceScore, credibilityScore, sentimentScore, compositeScore, item.popularity, source, item.url)}
                                </div>
                                <div class="result-meta">
                                    <span style="color: #666; font-weight: 500;">${source}</span>
                                    <span style="color: #666; font-weight: 600; margin-left: 12px;">Popularity: ${popularityScore} views</span>
                                </div>
                            </div>
                            <div class="result-content" style="line-height: 1.5; color: #555;">${content}</div>
                        `;
                        
                        resultsContainer.appendChild(card);
                        console.log(`Added item ${index + 1} to container`);
                        
                    } catch (itemError) {
                        console.error(`Error processing item ${index + 1}:`, itemError);
                    }
                });

                console.log('Container setup complete, showing results...');
                container.style.display = 'block';
                console.log('renderResults completed successfully');
                
                // Generate AI summary of all articles (this will create the two tiles in the summary container)
                const currentQuery = document.getElementById('searchInput').value.trim();
                generateSummary(sortedItems, currentQuery);
            } catch (error) {
                console.error('Fatal error in renderResults:', error);
                const container = document.getElementById('searchResults');
                if (container) {
                    container.innerHTML = '<p>Error displaying results</p>';
                    container.style.display = 'block';
                }
            }
        }

        // Helper function to calculate composite score
        function calculateCompositeScore(item) {
            let relevanceScore = 0;
            let credibilityScore = 0;
            let sentimentScore = 0;
            let popularityScore = 0;
            
            if (item.relevance_score !== undefined && item.relevance_score !== null) {
                if (typeof item.relevance_score === 'object' && item.relevance_score.score !== undefined) {
                    relevanceScore = parseFloat(item.relevance_score.score) || 0;
                } else {
                    relevanceScore = parseFloat(item.relevance_score) || 0;
                }
            }
            
            if (item.credibility_score !== undefined && item.credibility_score !== null) {
                credibilityScore = parseFloat(item.credibility_score) || 0;
            }
            
            if (item.sentiment_score !== undefined && item.sentiment_score !== null) {
                if (typeof item.sentiment_score === 'object') {
                    if (item.sentiment_score.polarity !== undefined) {
                        sentimentScore = parseFloat(item.sentiment_score.polarity) || 0;
                    } else if (item.sentiment_score.score !== undefined) {
                        sentimentScore = parseFloat(item.sentiment_score.score) || 0;
                    }
                } else {
                    sentimentScore = parseFloat(item.sentiment_score) || 0;
                }
            }
            
            if (item.popularity !== undefined && item.popularity !== null) {
                popularityScore = parseInt(item.popularity) || 0;
            }
            
            // Normalize scores to 0-100 scale and calculate weighted average
            const normalizedRelevance = relevanceScore * 100;
            const normalizedCredibility = credibilityScore;
            const normalizedSentiment = (sentimentScore + 1) * 50;
            const normalizedPopularity = Math.min(popularityScore / 10, 100);
            
            return (normalizedRelevance * 0.3 + normalizedCredibility * 0.3 + normalizedSentiment * 0.2 + normalizedPopularity * 0.2);
        }

        // Tooltip management
        let tooltipTimeout;
        let currentTooltip = null;
        let mouseX = 0;
        let mouseY = 0;

        // Track mouse position
        document.addEventListener('mousemove', function(e) {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        function showTooltip(element) {
            console.log('showTooltip called for element:', element);
            
            // Clear any existing timeout
            if (tooltipTimeout) {
                clearTimeout(tooltipTimeout);
            }

            // Hide any currently visible tooltip
            if (currentTooltip) {
                currentTooltip.classList.remove('show');
            }

            // Find the tooltip - look in the card container
            let tooltip;
            if (element.classList.contains('result-title')) {
                tooltip = element.parentElement.querySelector('[data-tooltip]');
            } else if (element.classList.contains('score-badge')) {
                tooltip = element.parentElement.querySelector('[data-tooltip]');
            }

            console.log('Found tooltip element:', tooltip);

            if (tooltip) {
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const tooltipWidth = 280;
                const tooltipHeight = 180;
                
                // Simple positioning logic
                let left = mouseX + 10;
                let top = mouseY + 10;
                
                // Keep tooltip in viewport
                if (left + tooltipWidth > viewportWidth - 10) {
                    left = mouseX - tooltipWidth - 10;
                }
                if (top + tooltipHeight > viewportHeight - 10) {
                    top = mouseY - tooltipHeight - 10;
                }
                
                // Final bounds check
                left = Math.max(10, left);
                top = Math.max(10, top);
                
                console.log('Setting tooltip position:', left, top);
                
                // Apply positioning with maximum z-index
                tooltip.style.left = left + 'px';
                tooltip.style.top = top + 'px';
                tooltip.style.zIndex = '9999999';
                tooltip.style.position = 'fixed';
                
                // Show tooltip immediately
                tooltip.classList.add('show');
                currentTooltip = tooltip;
                console.log('Tooltip should be visible now:', tooltip.classList.contains('show'));
                console.log('Tooltip computed style:', window.getComputedStyle(tooltip).visibility, window.getComputedStyle(tooltip).opacity);
            } else {
                console.log('No tooltip found for element:', element);
            }
        }

        function hideTooltip(element) {
            // Clear show timeout if it hasn't fired yet
            if (tooltipTimeout) {
                clearTimeout(tooltipTimeout);
            }

            // Find the tooltip
            let tooltip;
            if (element.classList.contains('result-title')) {
                tooltip = element.parentElement.querySelector('[data-tooltip]');
            } else if (element.classList.contains('score-badge')) {
                tooltip = element.parentElement.querySelector('[data-tooltip]');
            }

            if (tooltip) {
                // Hide with longer delay to prevent flickering
                tooltipTimeout = setTimeout(() => {
                    tooltip.classList.remove('show');
                    if (currentTooltip === tooltip) {
                        currentTooltip = null;
                    }
                    console.log('Tooltip hidden');
                }, 300);
            }
        }

        // Handle tooltip events for both titles and score badges
        document.addEventListener('mouseover', function(e) {
            if (e.target.classList.contains('result-title') || e.target.classList.contains('score-badge')) {
                showTooltip(e.target);
            }
        });

        document.addEventListener('mouseout', function(e) {
            if (e.target.classList.contains('result-title') || e.target.classList.contains('score-badge')) {
                hideTooltip(e.target);
            }
        });

        // Image display functionality for definition tile (restored)
        let currentImageQuery = null;
        let isImageLoading = false;
        let originalTileContent = null;
        
        // Image cache for faster hover display
        const imageCache = new Map();

        // Reset content when starting new search
        function resetDefinitionContent() {
            console.log('Resetting definition content for new search');
            originalTileContent = null;
            currentImageQuery = null;
        }

        async function preloadImageForDefinitionTile(query) {
            if (!query || imageCache.has(query)) return;
            
            console.log(`Preloading image for '${query}'`);
            
            try {
                const response = await fetch('/api/image-search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ query: query })
                });
                
                if (response.ok) {
                    const imageData = await response.json();
                    
                    if (imageData.image_url) {
                        // Cache the result for hover display
                        imageCache.set(query, imageData);
                        console.log(`Preloaded and cached image for '${query}'`);
                        
                        // Apply translucent background immediately
                        const definitionTile = document.querySelector('.definition-tile');
                        if (definitionTile) {
                            displayTranslucentBackground(definitionTile, imageData, query);
                        }
                    } else {
                        // Apply fallback translucent background
                        const definitionTile = document.querySelector('.definition-tile');
                        if (definitionTile) {
                            displayTranslucentFallbackBackground(definitionTile, query);
                        }
                    }
                }
                
            } catch (error) {
                console.error('Image preload error:', error);
                // Apply fallback translucent background
                const definitionTile = document.querySelector('.definition-tile');
                if (definitionTile) {
                    displayTranslucentFallbackBackground(definitionTile, query);
                }
            }
        }

        function showImageOnHover(tileElement, query) {
            if (!query || isImageLoading) return;
            
            currentImageQuery = query;
            
            // Check if we have a preloaded image
            if (imageCache.has(query)) {
                console.log(`Using preloaded image for hover '${query}'`);
                const cachedData = imageCache.get(query);
                displayImageAsBackground(tileElement, cachedData, query);
            } else {
                // Load image for this hover
                isImageLoading = true;
                loadImageForHover(tileElement, query);
            }
        }

        async function loadImageForHover(tileElement, query) {
            try {
                const response = await fetch('/api/image-search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ query: query })
                });
                
                if (response.ok && currentImageQuery === query) {
                    const imageData = await response.json();
                    
                    if (imageData.image_url) {
                        // Cache the result
                        imageCache.set(query, imageData);
                        displayImageAsBackground(tileElement, imageData, query);
                    } else {
                        displayFallbackBackground(tileElement, query);
                    }
                } else {
                    if (currentImageQuery === query) {
                        displayFallbackBackground(tileElement, query);
                    }
                }
                
            } catch (error) {
                console.error('Image hover load error:', error);
                if (currentImageQuery === query) {
                    displayFallbackBackground(tileElement, query);
                }
            } finally {
                isImageLoading = false;
            }
        }

        function hideImageOnHover(tileElement) {
            if (!isImageLoading) {
                const query = document.getElementById('searchInput').value.trim();
                
                // Remove hover-specific overlays
                const hoverOverlay = tileElement.querySelector('.image-overlay');
                if (hoverOverlay) {
                    hoverOverlay.remove();
                }
                
                const attribution = tileElement.querySelector('.image-attribution');
                if (attribution) {
                    attribution.remove();
                }
                
                // Restore definition content visibility
                const definitionContent = tileElement.querySelector('.definition-content');
                if (definitionContent) {
                    definitionContent.style.display = 'block';
                }
                
                // Restore translucent background
                if (imageCache.has(query)) {
                    const cachedData = imageCache.get(query);
                    displayTranslucentBackground(tileElement, cachedData, query);
                } else {
                    displayTranslucentFallbackBackground(tileElement, query);
                }
                
                currentImageQuery = null;
            }
        }

        function displayImageAsBackground(tileElement, imageData, query) {
            if (currentImageQuery !== query) return;
            
            // Remove translucent overlay if it exists
            const translucentOverlay = tileElement.querySelector('.translucent-overlay');
            if (translucentOverlay) {
                translucentOverlay.remove();
            }
            
            // Hide definition content during hover
            const definitionContent = tileElement.querySelector('.definition-content');
            if (definitionContent) {
                definitionContent.style.display = 'none';
            }
            
            // Set the image as background at 100% visibility
            tileElement.style.backgroundImage = `url('${imageData.image_url}')`;
            tileElement.style.backgroundSize = 'cover';
            tileElement.style.backgroundPosition = 'center';
            tileElement.style.backgroundRepeat = 'no-repeat';
            tileElement.style.transition = 'all 0.3s ease';
            
            // Style the heading for hover - keep it visible
            const heading = tileElement.querySelector('h3');
            if (heading) {
                heading.style.position = 'relative';
                heading.style.zIndex = '2';
                heading.style.color = '#0f172a';
                heading.style.textShadow = '0 2px 4px rgba(255,255,255,0.95), 0 0 25px rgba(255,255,255,0.4)';
                heading.style.fontWeight = '700';
                heading.style.letterSpacing = '0.02em';
                heading.style.display = 'block';
            }
        }
        
        function displayFallbackBackground(tileElement, query) {
            if (currentImageQuery !== query) return;
            
            // Remove translucent overlay if it exists
            const translucentOverlay = tileElement.querySelector('.translucent-overlay');
            if (translucentOverlay) {
                translucentOverlay.remove();
            }
            
            // Hide definition content during hover
            const definitionContent = tileElement.querySelector('.definition-content');
            if (definitionContent) {
                definitionContent.style.display = 'none';
            }
            
            // Generate cottage core gradient backgrounds at full visibility
            const colors = [
                { 
                    start: 'rgba(120, 113, 108, 0.8)', 
                    mid: 'rgba(168, 162, 158, 0.6)', 
                    end: 'rgba(196, 181, 173, 0.4)' 
                },
                { 
                    start: 'rgba(156, 163, 175, 0.8)', 
                    mid: 'rgba(209, 213, 219, 0.6)', 
                    end: 'rgba(243, 244, 246, 0.4)' 
                },
                { 
                    start: 'rgba(100, 116, 139, 0.8)', 
                    mid: 'rgba(148, 163, 184, 0.6)', 
                    end: 'rgba(203, 213, 225, 0.4)' 
                },
                { 
                    start: 'rgba(107, 114, 128, 0.8)', 
                    mid: 'rgba(156, 163, 175, 0.6)', 
                    end: 'rgba(229, 231, 235, 0.4)' 
                }
            ];
            const colorPair = colors[query.length % colors.length];
            
            tileElement.style.background = `linear-gradient(135deg, ${colorPair.start} 0%, ${colorPair.mid} 50%, ${colorPair.end} 100%)`;
            tileElement.style.transition = 'all 0.3s ease';
            
            // Style the heading for fallback hover - keep it visible
            const heading = tileElement.querySelector('h3');
            if (heading) {
                heading.style.position = 'relative';
                heading.style.zIndex = '2';
                heading.style.color = '#0f172a';
                heading.style.textShadow = '0 1px 3px rgba(255,255,255,0.9)';
                heading.style.fontWeight = '700';
                heading.style.letterSpacing = '0.02em';
                heading.style.display = 'block';
            }
        }

        function displayTranslucentBackground(tileElement, imageData, query) {
            console.log(`Applying translucent background for '${query}'`);
            
            // Set the image as translucent background
            tileElement.style.backgroundImage = `url('${imageData.image_url}')`;
            tileElement.style.backgroundSize = 'cover';
            tileElement.style.backgroundPosition = 'center';
            tileElement.style.backgroundRepeat = 'no-repeat';
            tileElement.style.transition = 'all 0.3s ease';
            
            // Add a more visible translucent overlay for default state
            const existingOverlay = tileElement.querySelector('.translucent-overlay');
            if (!existingOverlay) {
                const overlay = document.createElement('div');
                overlay.className = 'translucent-overlay';
                overlay.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: linear-gradient(
                        135deg, 
                        rgba(250, 249, 246, 0.75) 0%, 
                        rgba(245, 245, 244, 0.70) 25%,
                        rgba(238, 236, 235, 0.65) 50%, 
                        rgba(231, 229, 228, 0.60) 75%,
                        rgba(220, 216, 214, 0.55) 100%
                    );
                    backdrop-filter: blur(0.5px);
                    pointer-events: none;
                    z-index: 1;
                    border-radius: inherit;
                `;
                tileElement.appendChild(overlay);
            }
            
            // Style text for translucent background
            const definitionContent = tileElement.querySelector('.definition-content');
            if (definitionContent) {
                definitionContent.style.position = 'relative';
                definitionContent.style.zIndex = '2';
                definitionContent.style.color = '#2d2d2d';
                definitionContent.style.textShadow = '0 1px 2px rgba(255,255,255,0.8)';
                definitionContent.style.fontWeight = '500';
                definitionContent.style.letterSpacing = '0.01em';
            }
            
            const heading = tileElement.querySelector('h3');
            if (heading) {
                heading.style.position = 'relative';
                heading.style.zIndex = '2';
                heading.style.color = '#1f2937';
                heading.style.textShadow = '0 1px 3px rgba(255,255,255,0.9)';
                heading.style.fontWeight = '700';
                heading.style.letterSpacing = '0.02em';
            }
        }

        // Function to limit definition text to fit tile height
        function limitDefinitionText(text, maxChars = 800) {
            if (!text || text.length <= maxChars) return text;
            
            // Find the last complete sentence within the character limit
            let truncated = text.substring(0, maxChars);
            let lastSentence = truncated.lastIndexOf('.');
            let lastExclamation = truncated.lastIndexOf('!');
            let lastQuestion = truncated.lastIndexOf('?');
            
            let lastPunctuation = Math.max(lastSentence, lastExclamation, lastQuestion);
            
            if (lastPunctuation > maxChars * 0.7) {
                // If we found a sentence ending in the last 30% of the text, use that
                return truncated.substring(0, lastPunctuation + 1);
            } else {
                // Otherwise, find the last complete word
                let lastSpace = truncated.lastIndexOf(' ');
                if (lastSpace > maxChars * 0.8) {
                    return truncated.substring(0, lastSpace) + '...';
                } else {
                    return truncated + '...';
                }
            }
        }

        // Add event listeners for definition tile hover
        document.addEventListener('mouseover', function(e) {
            if (e.target.classList.contains('definition-tile') || e.target.closest('.definition-tile')) {
                const definitionTile = e.target.classList.contains('definition-tile') ? e.target : e.target.closest('.definition-tile');
                const query = document.getElementById('searchInput').value.trim();
                
                if (query && definitionTile) {
                    showImageOnHover(definitionTile, query);
                }
            }
        });

        document.addEventListener('mouseout', function(e) {
            if (e.target.classList.contains('definition-tile') || e.target.closest('.definition-tile')) {
                const definitionTile = e.target.classList.contains('definition-tile') ? e.target : e.target.closest('.definition-tile');
                
                // Add a small delay to prevent flickering
                setTimeout(() => {
                    if (!definitionTile.matches(':hover')) {
                        hideImageOnHover(definitionTile);
                    }
                }, 100);
            }
        });

        // Function to generate AI summary of articles
        async function generateSummary(articles, query) {
            const summaryContainer = document.getElementById('summaryContainer');
            if (!summaryContainer) return;

            try {
                // Create summary tiles container
                const summarySection = document.createElement('div');
                summarySection.className = 'summary-section';
                summarySection.style.cssText = `
                    display: grid;
                    grid-template-columns: 40% 58%;
                    gap: 2%;
                    margin-bottom: 20px;
                    width: 100%;
                `;

                // Create definition tile (30%)
                const definitionTile = document.createElement('div');
                definitionTile.className = 'definition-tile';
                definitionTile.innerHTML = `
                    <div class="definition-loading">
                        <div class="definition-spinner"></div>
                        <span>Looking up definition...</span>
                    </div>
                `;

                // Create intelligence summary tile (70%)
                const intelligenceTile = document.createElement('div');
                intelligenceTile.className = 'intelligence-tile';
                intelligenceTile.innerHTML = `
                    <h3>Intelligence Summary</h3>
                    <div class="summary-loading">
                        <div class="summary-spinner"></div>
                        <span>Analyzing ${articles.length} articles to generate insights...</span>
                    </div>
                `;

                summarySection.appendChild(definitionTile);
                summarySection.appendChild(intelligenceTile);
                
                // Add to summary container
                summaryContainer.appendChild(summarySection);

                // Prepare article data for summarization
                const articleData = articles.map(article => ({
                    title: article.title || 'Untitled',
                    content: (article.content || '').substring(0, 500),
                    source: article.source || 'Unknown',
                    credibility: article.credibility_score || 0,
                    sentiment: article.sentiment_score?.polarity || article.sentiment_score || 0
                }));

                console.log('Generating summary for articles:', articleData.length);

                // Make API call to generate summary
                const response = await fetch('/api/generate-summary', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        articles: articleData,
                        query: query
                    })
                });

                if (response.ok) {
                    const summaryData = await response.json();
                    console.log('Summary API response:', summaryData);
                    
                    // Get definition and intelligence text from separate fields
                    const definitionText = summaryData.definition || '';
                    const intelligenceText = summaryData.summary || 'No summary available';

                    // Display definition text by default with search query
                    if (definitionText) {
                        const limitedDefinitionText = limitDefinitionText(definitionText, 800);
                        definitionTile.innerHTML = `
                            <h3 style="margin: 0 0 12px 0; font-size: 18px; font-weight: 600; color: #1f2937; text-transform: uppercase;">${query}</h3>
                            <div class="definition-content">${limitedDefinitionText}</div>
                        `;
                        
                        // Load image immediately for preloading
                        preloadImageForDefinitionTile(query);
                    } else {
                        // Show placeholder when no definition found
                        definitionTile.innerHTML = `
                            <h3 style="margin: 0 0 12px 0; font-size: 18px; font-weight: 600; color: #1f2937; text-transform: uppercase;">${query}</h3>
                            <div class="definition-content" style="
                                color: #6b7280; 
                                font-style: italic;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                            ">
                                No definition available.
                            </div>
                        `;
                        
                        // Load image for preloading
                        preloadImageForDefinitionTile(query);
                    }

                    // Update intelligence summary tile
                    intelligenceTile.innerHTML = `
                        <h3>Intelligence Summary</h3>
                        <div class="summary-content">${intelligenceText}</div>
                        <div class="summary-meta">
                            <span>${articles.length} articles analyzed</span>
                            <span>Generated in ${summaryData.processing_time || 'N/A'}s</span>
                        </div>
                    `;
                } else {
                    console.error('Summary API failed:', response.status);
                    throw new Error(`API returned ${response.status}`);
                }

            } catch (error) {
                console.error('Summary generation failed:', error);
                
                // Show fallback summary
                const fallbackSummary = `Analysis of ${articles.length} articles about "${query}" shows diverse coverage across multiple sources. Key developments include ongoing reporting from various outlets with sustained media attention.`;
                
                // Update tiles with fallback
                const definitionTile = document.querySelector('.definition-tile');
                const intelligenceTile = document.querySelector('.intelligence-tile');
                const summarySection = document.querySelector('.summary-section');
                
                if (definitionTile) {
                    // Keep definition tile visible with placeholder for hover functionality
                    definitionTile.innerHTML = `
                        <h3 style="margin: 0 0 12px 0; font-size: 18px; font-weight: 600; color: #1f2937; text-transform: uppercase;">${query}</h3>
                        <div class="definition-content" style="
                            color: #6b7280; 
                            font-style: italic;
                            line-height: 1.5;
                            font-size: 14px;
                            height: 200px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                        ">
                            No definition available.
                        </div>
                    `;
                    
                    // Load image for preloading
                    preloadImageForDefinitionTile(query);
                }
                
                if (intelligenceTile) {
                    intelligenceTile.innerHTML = `
                        <h3>Intelligence Summary</h3>
                        <div class="summary-content">${fallbackSummary}</div>
                        <div class="summary-meta">
                            <span>${articles.length} articles analyzed</span>
                            <span>Fallback summary</span>
                        </div>
                    `;
                }
            }
        }
    </script>
    <script>
    (function() {
        const video = document.getElementById('starfield-video');
        if (!video) return;
        
        function handleVideo() {
            video.play().catch(function(error) {
                console.log("Video autoplay failed:", error);
            });
        }
        
        video.addEventListener('loadeddata', handleVideo);
        
        if (video.readyState >= 2) {
            handleVideo();
        }
    })();
    </script>
</body>
</html>